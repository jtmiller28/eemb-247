---
title: 'EEMB247/BMSE247: Computer lab 2: More Useful Things in R, and Linear Dynamical
  Systems in Continuous Time and Discrete Time'
author: "Cherie Briggs"
date: "April 7, 2022"
output:
  html_document: default
  html_notebook: default
  pdf_document: default
---
*Portions of this lesson were modified from W. N. Venables, D. M. Smith and the R Core Team, An Introduction to R, Notes on R: A Programming Environment for Data Analysis and Graphics Version 3.4.3 (2017-11-30).*

## A few more useful things in R

### Logical Operators
R allows manipulation of logical quantities. The elements of a logical vector can have the values TRUE, FALSE, and NA (for “not available”, see below). 

Logical vectors are generated by *conditions*. For example:
```{r}
x = 11:18
x
y = x < 15
y
```
creates the vector y of the same length as x with values FALSE corresponding to elements of x where the condition is not met and TRUE where it is.

The logical operators are <, <=, >, >=, == for exact equality and != for inequality. 

In addition if y and z are logical expressions, then y & z is their intersection (“and”), y | z is their union (“or”), and !y is the negation of y.

For example:
```{r}
x = 1:10
x
y = x < 5
z = x < 7
y
z
y & z
y | z
```
Logical vectors may be used in ordinary arithmetic, in which case they are *coerced* into numeric vectors, FALSE becoming 0 and TRUE becoming 1. 

```{r}
y+5
```

### Missing Values
In some cases the components of a vector may not be completely known. When an element or value is "not available"" or a "missing value"" in the statistical sense, a place within a vector may be reserved for it by assigning it the special value NA. In general any operation on an NA becomes an NA. The motivation for this rule is simply that if the specifcation of an operation is incomplete, the result cannot be known and hence is not available.

The function is.na(x) gives a logical vector of the same size as x with value TRUE if and only if the corresponding element in x is NA.
```{r}
z = c(1:3,NA)
z
ind = is.na(z)
ind
```
Notice that the logical expression x == NA is quite different from is.na(x) since NA is not really a value but a marker for a quantity that is not available. Thus x == NA is a vector of the same length as x all of whose values are NA as the logical expression itself is incomplete and hence undecidable.
```{r}
x = c(1:10,NA)
x
x == NA
```
Note that there is a second kind of "missing"" values which are produced by numerical computation, the so-called Not a Number, NaN, values. Examples are:
```{r}
0/0
```
or infinity minus infinity:
```{r}
Inf-Inf
```
is.na(xx) is TRUE both for NA and NaN values. To differentiate these,
is.nan(xx) is only TRUE for NaNs.

### Index Vectors; selecting and modifying subsets of a data set
Subsets of the elements of a vector may be selected by appending to the name of the vector an *index vector* in square brackets.

*An index vectors can be a logical vector.* In this case the index vector is recycled to the same length as the vector from which elements are to be selected. Values corresponding to TRUE in the index vector are selected and those corresponding to FALSE are omitted. For example, you can remove missing values by using !is.na() as an index vector:
```{r}
z = c(1:3,NA)
z
y = z[!is.na(z)]
y
```
What does this do?
```{r}
w = (z+1)[(!is.na(z)) & z>1]
w
```
It creates an object w and places in it the values of the vector z+1 for which the corresponding value in z was both non-missing and greater than 1.

*An index vectors can be a vector of positive integers.* The corresponding elements of the vector are selected and concatenated, in that order, in the result. The index vector can be of any length and the result is of the same length as the index vector. For example x[6] is the sixth component of x and
x[1:10] selects the first 10 elements of x:

```{r}
x=seq(12,30)
x
x[6]
x[1:10]
```
*An index vectors can be a vector of negative integers.* Such an index vector specifes the values to be excluded rather than included. For example:
```{r}
y = x[-(1:5)]
y
```
*An index vectors can be a vector of character strings.* This possibility only applies where an object has a *names* attribute to identify its components. In this case a sub-vector of the names vector may be used in the same way as the positive integral labels. The advantage is that alphanumeric names can be easier to remember than numeric indices. 
For example:
```{r}
fruit = c(5, 10, 1, 20)
names(fruit) = c("orange", "banana", "apple", "peach")
lunch = fruit[c("apple","orange")]
lunch
```

An indexed expression can also appear on the receiving end of an assignment, in which case the assignment operation is performed only on those elements of the vector. 

For example to replace any missing values in x by zeros:
```{r}
x = c(1, 4, NA, 5, 7, NA, 12)
x
x[is.na(x)] = 0
x
```
y[y < 0] <- -y[y < 0]  has the same effect as: y <- abs(y):
```{r}
y = c(-4, 5, 2, -3)
y
y[y < 0] = -y[y < 0]
y
```

### Conditional expressions
Conditional expressions allow you to do different things based on the value of a variable.
The basic template is:

if (condition) expression

```{r}
x = 5

if (x > 3) y = 12
y

```
or

if (condition) {  
expression(s) if true  
} else {  
expression(s) to do otherwise  
}  

```{r}
x<-5

if (x > 3 ) { 
    y = 12
    z = 3 
} else {  
    y = 0
    z = 200
} 

y
z

```
### Repetitive execution: for loops and avoiding for loops

####for or apply?

A for loop allows you to loop over values in a vector or list of numbers, and perform some operations over and over again. 

R has a family of functions, the *apply* family, which can sometimes be used to avoid for loops.  The apply family members include:

*apply* - apply over the margins of an array (e.g. the rows or columns of a matrix)  
*lapply* - apply over an object and return list  
*sapply* - apply over an object and return a simplified object (an array) if possible  
*vapply* - similar to sapply but you specify the type of object returned by the iterations  
Each of these has an argument FUN which takes a function to apply to each element of the object. 

For example, the *apply* function acts on arrays. It can be called using the command:  
apply(X, margin, FUN, ...)  
where:  
X is an array or a matrix 

MARGIN is a variable defining how the function is applied: when MARGIN=1, it applies over rows, whereas with MARGIN=2, it works over columns. Note that when you use the construct MARGIN=c(1,2), it applies to both rows and columns  

FUN, which is the function that you want to apply to the data. It can be any R function, including a User Defined Function.

```{r}
# Construct a 4x5 matrix
X = array(1:20, dim=c(4,5))
X
```
Sum the values of each column with `apply()`:
```{r}
apply(X, 2, sum)
```
Take the mean of each row:
```{r}
apply(X, 1, mean)
```

####Loops in R Are Slow
But, you can follow a number of golden rules to not make them too slow:  

1. Don’t use a loop when a vectorized alternative exists.

2. Don’t grow objects (via c, cbind, etc.) during the loop - R has to create a new object and copy across the information just to add a new element or row/column.

3. Allocate an object to hold the results and fill it in during the loop.

#### For loops
The basic structure of a for loop is:  
for (variable in vector) {  
expression(s)  
}  

For example, if we wanted to add 5 to each element of the vector x, and store it in vector y, we could do it with a for loop:
```{r}
x = c(1, 3, 2, 4, 5, 7, 9, 0, 3)

y = rep(0,length(x))  # allocate an object y to hold the answer

for (i in 1:length(x)) {
  y[i] = x[i] + 5
}
y
```
However, in R, we can do this much more efficiently using the command:
```{r}
y = x + 5
y
```


What does the following code do?
```{r}
x = c(1, 3, 2, 4, 5, 7, 9, 0, 3)
x

y=rep(0,length(x)-1) # allocate an object y to hold the answer
 
for (i in 1:length(x)-1) {
  y[i] = x[i] + x[i+1] 
}
y

```

## Numerical Solutions to Discrete-Time Models Using For Loops

Last week we found that in order to obtain a numerical solution to an ordinary differential equation (ODE), we needed to use one of the numerical ODE solvers in the deSolve package.  This isn't necessary for discrete-time equations. We can instead obtain numerical solutions to discrete-time difference equations using for loops.  

For example, consider the model:

$$
N_{t+1} = RN_t (1-N_t)
$$
with the initial condition $N_0 = 0.3$ (that is, $N_t$ = 0.3 at time $t = 0$), and the parameter $R = 2.5$.

We can calculate the value of $N_1$ just by plugging in the values for $R$ and $N_0$. Once we know the value of $N_1$, we can then calculate the value of $N_2$, and so on.  This can be done using a for loop:
```{r}
R = 2.5
initial_N = 0.3
max_time = 20

N = rep(0, max_time + 1)
N[1] = initial_N
for (t in 1:max_time) {
  N[t+1] = R*N[t]*(1 - N[t])
}

times = seq(0,max_time)
plot(times,N,type="b",xlab="time",ylab="N")
```


## Homework #2: Solutions to Linear Dynamical Systems in Discrete Time and Continuous Time

### Discrete Time
1. Consider the systems of linear discrete-time equations:

$x_{t+1} = x_t + 0.5 y_t$  
$y_{t+1} = 0.5 x_t + y_t$  

with initial conditions:  
$x_0 = 0$  
$y_0 = 1$  

(a) Calculate and plot the *numerical solution* to this set of equations for times $t = 0$ to $10$.

(b) Calculate and plot the *analytical solution* to this set of equations for times $t = 0$ to $10$. (In this case, you need to do math!)

### Continuous Time
2. Consider the systems of linear ordinary differential equations:

$\frac{dx}{dt} = x + 0.5 y$  
$\frac{dy}{dt} = 0.5 x + y$  

with initial conditions:  
$x_0 = 0$  
$y_0 = 1$  

(a) Calculate and plot the *numerical solution* to this set of equations for times $t = 0$ to $10$.

(b) Calculate and plot the *analytical solution* to this set of equations for times $t = 0$ to $10$. (In this case, you need to do math!)
